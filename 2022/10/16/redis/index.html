<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.13.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Redis命令">
<meta property="og:type" content="article">
<meta property="og:title" content="redis">
<meta property="og:url" content="http://example.com/2022/10/16/redis/index.html">
<meta property="og:site_name" content="我要去大厂">
<meta property="og:description" content="Redis命令">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221115141834880.png?raw=true">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221115143017553.png?raw=true?raw=true">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221115141948937.png?raw=true">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221115170352663.png?raw=true">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221115172440822.png?raw=true">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221116104210773.png?raw=true">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221115141824141.png?raw=true?lastModify=1668564765">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221116105202189.png?raw=true">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221116105223166.png?raw=true">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221116101924212.png?raw=true">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221116101939610.png?raw=true">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221116145341219.png?raw=true">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221116101250658.png?raw=true">
<meta property="og:image" content="c:\Users\19094\AppData\Roaming\Typora\typora-user-images\image-20240306195238629.png">
<meta property="og:image" content="c:\Users\19094\AppData\Roaming\Typora\typora-user-images\image-20240306195617663.png">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221116110707618.png?raw=true">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221116114206050.png?raw=true">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221116115912733.png?raw=true">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221116115806333.png?raw=true">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221116115731949.png?raw=true">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221116134731704.png?raw=true">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221116144548959.png?raw=true">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221122200943822.png?raw=true">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221122200956718.png?raw=true">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221124203744462.png?raw=true">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221124211547737.png?raw=true">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221209151737449.png">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221125164247130.png?raw=true">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221125201625463.png?raw=true">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221125193052913.png?raw=true">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221125193243372.png?raw=true">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221125202133335.png?raw=true">
<meta property="og:image" content="c:\Users\19094\AppData\Roaming\Typora\typora-user-images\image-20240307204427362.png">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221209151945054.png">
<meta property="og:image" content="c:\Users\19094\AppData\Roaming\Typora\typora-user-images\image-20240307214256396.png">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221126140241320.png?raw=true">
<meta property="og:image" content="c:\Users\19094\AppData\Roaming\Typora\typora-user-images\image-20240306224029479.png">
<meta property="og:image" content="c:\Users\19094\AppData\Roaming\Typora\typora-user-images\image-20240306224014494.png">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221126174401626.png?raw=true">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221126210244915.png?raw=true">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221126214631747.png?raw=true">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221126220035968.png?raw=true">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/1140467/202007/1140467-20200701171414676-262569387.png">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20230211210341364.png">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20230211211841853.png">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20230211212024840.png">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20230314221548482.png">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20230315194626824.png">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20230315194730628.png">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20230315194702924.png">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20230325161238218.png">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20230624171710716.png">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20230319191308539.png">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20230325163532764.png">
<meta property="og:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20230918173952155.png">
<meta property="article:published_time" content="2022-10-16T11:20:46.000Z">
<meta property="article:modified_time" content="2024-04-08T14:25:24.023Z">
<meta property="article:author" content="bean">
<meta property="article:tag" content="图解redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221115141834880.png?raw=true">


<link rel="canonical" href="http://example.com/2022/10/16/redis/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2022/10/16/redis/","path":"2022/10/16/redis/","title":"redis"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>redis | 我要去大厂</title>
  






  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">我要去大厂</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E5%91%BD%E4%BB%A4"><span class="nav-number">1.</span> <span class="nav-text">Redis命令</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E7%9A%84%E5%86%85%E5%AD%98%E5%A4%84%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">Redis的内存处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#redis%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="nav-number">2.1.</span> <span class="nav-text">redis过期删除策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="nav-number">2.2.</span> <span class="nav-text">redis内存淘汰策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E9%80%89%E5%9E%8B"><span class="nav-number">2.2.1.</span> <span class="nav-text">缓存淘汰策略选型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.</span> <span class="nav-text">Redis底层数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%95%E5%B1%82%E7%9A%84%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="nav-number">3.1.</span> <span class="nav-text">底层的总体架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%95%E5%B1%82string%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.2.</span> <span class="nav-text">底层string的数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%95%E5%B1%82ZipList%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.3.</span> <span class="nav-text">底层ZipList数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%95%E5%B1%82QuickList%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.4.</span> <span class="nav-text">底层QuickList的数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%95%E5%B1%82SkipList%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.5.</span> <span class="nav-text">底层SkipList的数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E4%B8%ADList%E7%9A%84%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84-%E9%87%87%E7%94%A8QuickList"><span class="nav-number">3.6.</span> <span class="nav-text">Redis中List的整体结构(采用QuickList)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E4%B8%ADSet%E7%9A%84%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84-%E9%87%87%E7%94%A8Dict%E6%88%96IntSet"><span class="nav-number">3.7.</span> <span class="nav-text">Redis中Set的整体结构(采用Dict或IntSet)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E4%B8%ADZSet%E7%9A%84%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84-%E9%87%87%E7%94%A8ZipList%E6%88%96SkipList-Dict"><span class="nav-number">3.8.</span> <span class="nav-text">Redis中ZSet的整体结构(采用ZipList或SkipList+Dict)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E4%B8%ADHash%E7%9A%84%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84-ZipList%E6%88%96Dict"><span class="nav-number">3.9.</span> <span class="nav-text">Redis中Hash的整体结构(ZipList或Dict)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E4%B8%ADbitmap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%91%BD%E4%BB%A4"><span class="nav-number">3.10.</span> <span class="nav-text">Redis中bitmap数据结构和命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%A7%A3%E5%86%B3%E8%B6%85%E4%B9%B0%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98"><span class="nav-number">3.11.</span> <span class="nav-text">Redis分布式锁解决超买超卖问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E7%BC%93%E5%AD%98%E4%B8%8E%E9%9B%86%E7%BE%A4"><span class="nav-number">4.</span> <span class="nav-text">Redis缓存与集群</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="nav-number">4.1.</span> <span class="nav-text">Redis缓存穿透</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-number">4.2.</span> <span class="nav-text">Redis缓存雪崩</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%88%E8%AE%BE%E7%BD%AE%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%E6%B0%B8%E4%B8%8D%E8%BF%87%E6%9C%9F%E3%80%81%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98%E6%97%B6%EF%BC%8C%E5%8A%A0%E5%85%A8%E5%B1%80%E9%94%81%EF%BC%8C%E4%BF%9D%E8%AF%81%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E8%B5%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%89"><span class="nav-number">4.3.</span> <span class="nav-text">Redis缓存击穿（设置热点数据永不过期、更新缓存时，加全局锁，保证只有一个走数据库）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDB-Redis-Database-Backup-file-%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6"><span class="nav-number">4.4.</span> <span class="nav-text">RDB (Redis Database Backup file 数据备份文件)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOF-Append-Only-File-%E8%BF%BD%E5%8A%A0%E6%96%87%E4%BB%B6"><span class="nav-number">4.5.</span> <span class="nav-text">AOF (Append Only File 追加文件)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDB%E4%B8%8EAOF%E6%B7%B7%E5%90%88"><span class="nav-number">4.6.</span> <span class="nav-text">RDB与AOF混合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDB%E4%B8%8EAOF%E5%AF%B9%E6%AF%94"><span class="nav-number">4.7.</span> <span class="nav-text">RDB与AOF对比</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E9%9B%86%E7%BE%A4-%E4%B8%80%E4%B8%BB%E5%A4%9A%E4%BB%8E%EF%BC%8C%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="nav-number">4.8.</span> <span class="nav-text">主从集群(一主多从，读写分离)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5"><span class="nav-number">4.8.1.</span> <span class="nav-text">数据同步</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4-%E4%B8%80%E4%B8%AAmaster%EF%BC%8C%E5%A4%9A%E4%B8%AAslave"><span class="nav-number">4.9.</span> <span class="nav-text">哨兵集群(一个master，多个slave)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4-%E5%A4%9A%E4%B8%AAmaster%EF%BC%8C%E5%A4%9A%E4%B8%AAslave"><span class="nav-number">4.10.</span> <span class="nav-text">分片集群(多个master，多个slave)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%E4%B8%8B%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BEkey-Redis%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%E9%87%87%E7%94%A8%E5%93%88%E5%B8%8C%E6%A7%BD%E8%80%8C%E9%9D%9E%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C"><span class="nav-number">4.10.1.</span> <span class="nav-text">分片集群下如何查找key (Redis分片集群采用哈希槽而非一致性哈希)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%E4%B8%8B%E8%8A%82%E7%82%B9%E5%A2%9E%E5%88%A0"><span class="nav-number">4.10.2.</span> <span class="nav-text">分片集群下节点增删</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.</span> <span class="nav-text">Redis网络模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E7%A7%8DIO"><span class="nav-number">5.1.</span> <span class="nav-text">五种IO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9EIO"><span class="nav-number">5.1.1.</span> <span class="nav-text">阻塞IO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9EIO"><span class="nav-number">5.1.2.</span> <span class="nav-text">非阻塞IO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NIO%E4%B8%BA%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9EIO"><span class="nav-number">5.1.3.</span> <span class="nav-text">NIO为同步非阻塞IO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E7%9A%84NIO"><span class="nav-number">5.1.4.</span> <span class="nav-text">Java的NIO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AIO%E4%B8%BA%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9EIO"><span class="nav-number">5.1.5.</span> <span class="nav-text">AIO为异步非阻塞IO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-x2F-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%9Aselect%EF%BC%8Cpoll%EF%BC%8Cepoll"><span class="nav-number">5.1.6.</span> <span class="nav-text">I&#x2F;O多路复用：select，poll，epoll</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#select"><span class="nav-number">5.1.6.1.</span> <span class="nav-text">select</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll"><span class="nav-number">5.1.6.2.</span> <span class="nav-text">epoll</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.2.</span> <span class="nav-text">Redis单线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#redis%E9%80%89%E6%8B%A9%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%E5%8E%9F%E5%9B%A0%EF%BC%9A"><span class="nav-number">5.2.0.1.</span> <span class="nav-text">redis选择单线程处理命令原因：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB"><span class="nav-number">5.2.0.2.</span> <span class="nav-text">redis为什么快</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.2.0.3.</span> <span class="nav-text">Redis单线程模型</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">6.</span> <span class="nav-text">Redis常见面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">6.1.</span> <span class="nav-text">Redis作为缓存如何保证数据一致性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E7%83%ADkey%E9%97%AE%E9%A2%98"><span class="nav-number">6.2.</span> <span class="nav-text">Redis热key问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%83%ADkey"><span class="nav-number">6.2.1.</span> <span class="nav-text">什么是热key</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%8F%91%E7%8E%B0%E7%83%ADkey"><span class="nav-number">6.2.2.</span> <span class="nav-text">如何发现热key</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%83%ADkey"><span class="nav-number">6.2.3.</span> <span class="nav-text">如何解决热key</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">6.3.</span> <span class="nav-text">布隆过滤器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%AE%80%E4%BB%8B"><span class="nav-number">6.3.1.</span> <span class="nav-text">布隆过滤器简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-number">6.3.2.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9"><span class="nav-number">6.3.3.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8"><span class="nav-number">6.3.4.</span> <span class="nav-text">应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%8Ehashmap%E7%9B%B8%E6%AF%94%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">6.3.5.</span> <span class="nav-text">布隆过滤器与hashmap相比的好处</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95"><span class="nav-number">6.4.</span> <span class="nav-text">一致性hash算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%AE%E9%80%9Ahash%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="nav-number">6.4.1.</span> <span class="nav-text">普通hash算法：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95"><span class="nav-number">6.4.2.</span> <span class="nav-text">一致性Hash算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="nav-number">6.4.3.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%9C%A8Hash%E7%8E%AF%E7%9A%84%E5%80%BE%E6%96%9C%E9%97%AE%E9%A2%98"><span class="nav-number">6.4.4.</span> <span class="nav-text">存在Hash环的倾斜问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">6.5.</span> <span class="nav-text">分布式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E7%82%B9"><span class="nav-number">6.5.1.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">6.5.2.</span> <span class="nav-text">实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%AF%B9%E9%AB%98%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E6%97%B6%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">6.5.3.</span> <span class="nav-text">面对高并发场景时分布式锁的优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E4%B8%8Bmget%E4%BD%BF%E7%94%A8"><span class="nav-number">6.5.4.</span> <span class="nav-text">集群模式下mget使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E5%A4%A7Key"><span class="nav-number">6.5.5.</span> <span class="nav-text">Redis大Key</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%A7key%E8%A7%84%E5%AE%9A"><span class="nav-number">6.5.5.1.</span> <span class="nav-text">大key规定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">6.5.5.2.</span> <span class="nav-text">引发的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">6.5.5.3.</span> <span class="nav-text">解决方案</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="bean"
      src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fc-ssl.duitang.com%2Fuploads%2Fblog%2F202107%2F18%2F20210718183516_c5a92.thumb.1000_0.jpg&refer=http%3A%2F%2Fc-ssl.duitang.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1666018689&t=8347c2b828598fc354614daabb33aead">
  <p class="site-author-name" itemprop="name">bean</p>
  <div class="site-description" itemprop="description">博客记录学习生活</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/16/redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fc-ssl.duitang.com%2Fuploads%2Fblog%2F202107%2F18%2F20210718183516_c5a92.thumb.1000_0.jpg&refer=http%3A%2F%2Fc-ssl.duitang.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1666018689&t=8347c2b828598fc354614daabb33aead">
      <meta itemprop="name" content="bean">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我要去大厂">
      <meta itemprop="description" content="博客记录学习生活">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="redis | 我要去大厂">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          redis
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-10-16 19:20:46" itemprop="dateCreated datePublished" datetime="2022-10-16T19:20:46+08:00">2022-10-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-08 22:25:24" itemprop="dateModified" datetime="2024-04-08T22:25:24+08:00">2024-04-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">面试题</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a>Redis命令</h1><span id="more"></span>     

<ul>
<li><p>keys k*     列出所有前缀为k的键值</p>
</li>
<li><p>exists key    判断key是否存在于数据库中</p>
</li>
<li><p>expire k1 10    设置key的最大生存时间</p>
</li>
<li><p>ttl k1   查看key的剩余生存时间</p>
</li>
<li><p>setnx student1 1   对key为student1的设置分布式锁</p>
</li>
<li><p>get student1    拿锁</p>
</li>
<li><p>zset命令 </p>
<ul>
<li><p>zadd students score value</p>
</li>
<li><p>zrange students start end   降序输出范围内的元素</p>
</li>
<li><p>zrevrange students start end   升序输出范围内的元素</p>
</li>
<li><p>zrangebyscore students score1 score2   获取score1-score2范围内的元素</p>
</li>
<li><p>zrevrangebyscore students score2 score1   获取score1-score2范围内的元素</p>
</li>
<li><p>zrank students value     获取value对应的升序排名</p>
</li>
<li><p>zrevrank students value     获取value对应的降序排名</p>
</li>
<li><p>zcard  students     获取students中元素个数</p>
</li>
</ul>
</li>
<li><p>set命令</p>
<ul>
<li>sunion myset youset       并集</li>
<li>sinter  myset youset       交集</li>
<li>sdiff  myset youset       差集</li>
<li>scard</li>
<li>sadd</li>
<li>srem       删除</li>
<li>smembers</li>
<li>sismember</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gzu_01/article/details/135362903">hash命令</a></p>
<ul>
<li>hget key1 key2</li>
<li>hgetall</li>
<li>hset</li>
<li>hexists</li>
<li>hlen</li>
<li>hdel</li>
<li>hkeys</li>
</ul>
</li>
</ul>
<h1 id="Redis的内存处理"><a href="#Redis的内存处理" class="headerlink" title="Redis的内存处理"></a>Redis的内存处理</h1><h2 id="redis过期删除策略"><a href="#redis过期删除策略" class="headerlink" title="redis过期删除策略"></a>redis过期删除策略</h2><!--more-->

<p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221115141834880.png?raw=true" alt="image-20221115141834880"></p>
<h2 id="redis内存淘汰策略"><a href="#redis内存淘汰策略" class="headerlink" title="redis内存淘汰策略"></a>redis内存淘汰策略</h2><p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221115143017553.png?raw=true?raw=true" alt="image-20221115143017553"></p>
<p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221115141948937.png?raw=true" alt="image-20221115141948937"></p>
<h3 id="缓存淘汰策略选型"><a href="#缓存淘汰策略选型" class="headerlink" title="缓存淘汰策略选型"></a>缓存淘汰策略选型</h3><ul>
<li>LRU：<ul>
<li>适用于具有时间局部性的场景</li>
</ul>
</li>
<li>LFU：<ul>
<li>适用于数据访问热度分布不均匀的场景，比如电商网站中的热门商品和冷门商品，只有少量的热门数据集中访问比较多，而大量的数据很少被访问</li>
</ul>
</li>
</ul>
<h1 id="Redis底层数据结构"><a href="#Redis底层数据结构" class="headerlink" title="Redis底层数据结构"></a>Redis底层数据结构</h1><h2 id="底层的总体架构"><a href="#底层的总体架构" class="headerlink" title="底层的总体架构"></a>底层的总体架构</h2><p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221115170352663.png?raw=true" alt="image-20221115170352663"></p>
<p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221115172440822.png?raw=true" alt="image-20221115172440822"></p>
<p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221116104210773.png?raw=true" alt="image-20221116104210773"></p>
<h2 id="底层string的数据结构"><a href="#底层string的数据结构" class="headerlink" title="底层string的数据结构"></a>底层string的数据结构</h2><p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221115141824141.png?raw=true?lastModify=1668564765" alt="image-20221115141824141"></p>
<p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221116105202189.png?raw=true" alt="image-20221116105202189"></p>
<p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221116105223166.png?raw=true" alt="image-20221116105223166"></p>
<p>应用场景：</p>
<ul>
<li>计数器</li>
<li>分布式锁</li>
<li>缓存对象</li>
</ul>
<h2 id="底层ZipList数据结构"><a href="#底层ZipList数据结构" class="headerlink" title="底层ZipList数据结构"></a>底层ZipList数据结构</h2><p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221116101924212.png?raw=true" alt="image-20221116101924212"></p>
<p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221116101939610.png?raw=true" alt="image-20221116101939610"></p>
<p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221116145341219.png?raw=true" alt="image-20221116145341219"></p>
<h2 id="底层QuickList的数据结构"><a href="#底层QuickList的数据结构" class="headerlink" title="底层QuickList的数据结构"></a>底层QuickList的数据结构</h2><p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221116101250658.png?raw=true" alt="image-20221116101250658"></p>
<h2 id="底层SkipList的数据结构"><a href="#底层SkipList的数据结构" class="headerlink" title="底层SkipList的数据结构"></a>底层SkipList的数据结构</h2><p>​	普通链表在查找元素的时候，查询效率非常低，时间复杂度是O(N)，于是就出现了跳表。跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表，通过以空间换时间的方式，快读定位数据。</p>
<p>​	维持相邻两层的节点数量的比例为接近 2 : 1 ，每个跳表节点中包括level数组， level 数组大小代表当前节点在多层链表中所达到的层数，level 数组中的每一个元素代表跳表的一层，每一个level 数组元素都由一个forward指针和一个span组成，forward指向当前跳表节点在每一层所能抵达的下一个跳表节点，span代表某一层相邻两节点之间的距离，主要用于rank查询某个元素时，计算排名O(logn)，<strong>计算排名即span之和的过程也就是类似于查找数据过程的逆方向</strong>。每个跳表节点都有一个指针指向前一个节点，这样倒序查找即降序时很方便。在查找数据时先从头节点的最高层开始，如果要查找数据的权重大于当前节点的权重，则访问该层的下一个节点，如果下一个节点为空或者要查找的数据的权重大于当前节点的权重，则去下一层指针继续查找，直到查到目标数据，时间复杂度为到 O(logN)。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zskiplistNode &#123;</span><br><span class="line">    <span class="comment">// member 对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    struct zskiplistNode *backward;</span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    struct zskiplistLevel &#123;</span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        struct zskiplistNode *forward;</span><br><span class="line">        <span class="comment">// 这个层跨越的节点数量</span></span><br><span class="line">        unsigned <span class="type">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\19094\AppData\Roaming\Typora\typora-user-images\image-20240306195238629.png" alt="image-20240306195238629"></p>
<p><img src="C:\Users\19094\AppData\Roaming\Typora\typora-user-images\image-20240306195617663.png" alt="image-20240306195617663"></p>
<h2 id="Redis中List的整体结构-采用QuickList"><a href="#Redis中List的整体结构-采用QuickList" class="headerlink" title="Redis中List的整体结构(采用QuickList)"></a>Redis中List的整体结构(采用QuickList)</h2><p>​	在 Redis3.2 版本前，Redis 列表使用 压缩列表 ZipList 或者 双向链表 LinkedList (next和pre指针浪费空间)作为底层实现</p>
<p>​	在 Redis3.2 版本后，Redis 列表使用 快速链表 QucikList (ZipList + LinkedList) 结构作为底层实现 </p>
<p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221116110707618.png?raw=true" alt="image-20221116110707618"></p>
<p>应用场景：</p>
<ul>
<li>消息队列</li>
</ul>
<h2 id="Redis中Set的整体结构-采用Dict或IntSet"><a href="#Redis中Set的整体结构-采用Dict或IntSet" class="headerlink" title="Redis中Set的整体结构(采用Dict或IntSet)"></a>Redis中Set的整体结构(采用Dict或IntSet)</h2><p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221116114206050.png?raw=true" alt="image-20221116114206050"></p>
<p>应用场景：</p>
<ul>
<li><p>点赞</p>
</li>
<li><p>共同关注</p>
</li>
</ul>
<h2 id="Redis中ZSet的整体结构-采用ZipList或SkipList-Dict"><a href="#Redis中ZSet的整体结构-采用ZipList或SkipList-Dict" class="headerlink" title="Redis中ZSet的整体结构(采用ZipList或SkipList+Dict)"></a>Redis中ZSet的整体结构(采用ZipList或SkipList+Dict)</h2><p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221116115912733.png?raw=true" alt="image-20221116115912733"></p>
<p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221116115806333.png?raw=true" alt="image-20221116115806333"></p>
<p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221116115731949.png?raw=true" alt="image-20221116115731949"></p>
<p>由于ziplist无法排序并且数据量小，所以在使用ziplist存储结构时，可以在业务编码时进行排序。</p>
<p>常用命令：</p>
<ul>
<li>zadd key score1 value1</li>
<li>zrem key value1</li>
<li>zrange key start end</li>
<li>zincrby key num1 value1 </li>
<li>zrangebyscore key</li>
</ul>
<p>应用场景：</p>
<ul>
<li>排行榜</li>
<li>对点赞数目、电话号码排序</li>
</ul>
<h2 id="Redis中Hash的整体结构-ZipList或Dict"><a href="#Redis中Hash的整体结构-ZipList或Dict" class="headerlink" title="Redis中Hash的整体结构(ZipList或Dict)"></a>Redis中Hash的整体结构(ZipList或Dict)</h2><p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221116134731704.png?raw=true" alt="image-20221116134731704"></p>
<p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221116144548959.png?raw=true" alt="image-20221116144548959"></p>
<p>应用场景                                                                                                                                                                                                                                                                                                                                                                </p>
<ul>
<li>缓存用户</li>
<li>缓存购物车</li>
</ul>
<h2 id="Redis中bitmap数据结构和命令"><a href="#Redis中bitmap数据结构和命令" class="headerlink" title="Redis中bitmap数据结构和命令"></a>Redis中bitmap数据结构和命令</h2><p>bitmap底层采用redis中string数据结构存储，即sds，一个字符数组。</p>
<p>redis中string最大为512MB，能够存储2^32个bitmap数据</p>
<p>常用命令：</p>
<ul>
<li>setbit login_2022_10 2 1    [commend，key，index，value]</li>
<li>getbit login_2022_10 2</li>
<li>bitcount login_2022_10 1  [comment，key，value]</li>
<li>bitpos login_2022_10 1      &#x2F;&#x2F;login_2022_10里面以1开头的下标</li>
</ul>
<p>应用场景：</p>
<ul>
<li>签到统计</li>
<li>判断登录状态</li>
</ul>
<h2 id="Redis分布式锁解决超买超卖问题"><a href="#Redis分布式锁解决超买超卖问题" class="headerlink" title="Redis分布式锁解决超买超卖问题"></a>Redis分布式锁解决超买超卖问题</h2><p>​		redis虽然支持事务，但是与数据库的事务不同，虽然redis事务能保证原子性，但不能保证一致性。因此需要编写lua脚本搭配redis解决一致性问题</p>
<h1 id="Redis缓存与集群"><a href="#Redis缓存与集群" class="headerlink" title="Redis缓存与集群"></a>Redis缓存与集群</h1><h2 id="Redis缓存穿透"><a href="#Redis缓存穿透" class="headerlink" title="Redis缓存穿透"></a>Redis缓存穿透</h2><p>​		客户端请求的数据在缓存和数据库中都不存在，缓存永远不会生效，这些请求会一直打入到数据库</p>
<p>​		解决方法：</p>
<ul>
<li><p>缓存空对象：可能造成短期内数据不一致问题，数据库数据修改缓存不知道</p>
<p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221122200943822.png?raw=true" alt="image-20221122200943822"></p>
</li>
<li><p>布隆过滤：占用内存少，实现复杂</p>
<p>将数据库中的数据利用hash算法转化为hashcode，存储到布隆过滤器(bitMap)里边对应hashcode位置是否为1</p>
</li>
</ul>
<p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221122200956718.png?raw=true" alt="image-20221122200956718"></p>
<h2 id="Redis缓存雪崩"><a href="#Redis缓存雪崩" class="headerlink" title="Redis缓存雪崩"></a>Redis缓存雪崩</h2><p>​		同一时间段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p>
<p>​		解决方案：</p>
<ul>
<li>利用Redis集群高可用</li>
<li>给不同的key的TTL添加随机值，随机时间到期</li>
<li>给业务添加多级缓存</li>
<li>给缓存业务添加降级限流</li>
</ul>
<h2 id="Redis缓存击穿（设置热点数据永不过期、更新缓存时，加全局锁，保证只有一个走数据库）"><a href="#Redis缓存击穿（设置热点数据永不过期、更新缓存时，加全局锁，保证只有一个走数据库）" class="headerlink" title="Redis缓存击穿（设置热点数据永不过期、更新缓存时，加全局锁，保证只有一个走数据库）"></a>Redis缓存击穿（设置热点数据永不过期、更新缓存时，加全局锁，保证只有一个走数据库）</h2><p>就是一个频繁访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库很大冲击。</p>
<p>​		解决方案：</p>
<ul>
<li>互斥锁策略：强一致性</li>
<li>设置热点数据永不过期</li>
<li>逻辑过期策略：缓存对象时，为对象添加一个过期时间字段，当取对象时判断对象的过期字段是否过期，若过期则获取互斥锁开启一个新线程从数据库中取数据写入到redis中重置过期时间。无法保证强一致性，更看重用户体验</li>
<li>设置一个定时任务，定时将缓存的时间刷新</li>
</ul>
<h2 id="RDB-Redis-Database-Backup-file-数据备份文件"><a href="#RDB-Redis-Database-Backup-file-数据备份文件" class="headerlink" title="RDB (Redis Database Backup file 数据备份文件)"></a>RDB (Redis Database Backup file 数据备份文件)</h2><p>​	RDB：redis数据备份文件，数据快照，将redis内存中所有数据以二进制格式记录到磁盘中，redis实例故障重启后，从磁盘读取数据快照恢复数据。</p>
<p>​	RDB执行的时机是：①自己设置的save 10 100 (10秒内有100次写入，save指bgsave命令)，②正常关闭服务器</p>
<p>​	RDB的缺点：每两次持久化之间产生的数据可能会因为宕机而丢失，而且fork子进程将数据记录到磁盘时非常耗时间 </p>
<p>​	RDB的bgsave的基本流程：</p>
<ul>
<li><p>在主进程中fork一个子进程，主进程和子进程共享内存空间 (本质上是将主进程用于访问内存的页表复制给子进程)</p>
</li>
<li><p>子进程读取内存空间中的数据写入新的RDB文件</p>
</li>
<li><p>用新的RDB文件替换旧的</p>
</li>
</ul>
<p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221124203744462.png?raw=true" alt="image-20221124203744462"></p>
<h2 id="AOF-Append-Only-File-追加文件"><a href="#AOF-Append-Only-File-追加文件" class="headerlink" title="AOF (Append Only File 追加文件)"></a>AOF (Append Only File 追加文件)</h2><p>​		Redis每处理一个写命令都会记录在AOF文件中，是一个用于记录执行命令的日志文件。AOF可以每条命令记录刷盘一次，也可以每一秒刷盘一次，也可以将命令写入AOF文件的内核缓冲区，然后操作系统决定何时将缓冲区内容写回硬盘。AOF文件长度增加一倍或者总体积超过64mb时，触发bgrewriteaof，将同一个key的多次写操作合并删除实现AOF文件压缩。AOF不用适用预写日志策略(wal)，redis需要先先执行指令并检查语法错误，然后再将正确的指令写入日志文件。直接写入日志就无法保证指令正确</p>
<h2 id="RDB与AOF混合"><a href="#RDB与AOF混合" class="headerlink" title="RDB与AOF混合"></a>RDB与AOF混合</h2><p>​		简单概况就是AOF文件中前半段存储RDB数据(二进制)，后半段存储AOF数据(指令)。</p>
<p>​		在执行bgrewriteaof之前，产生的指令存储在AOF文件中，bgrewriteaof后Fork子进程将redis内存中的数据以RDB形式拷贝一份到新的AOF文件中，并在拷贝的过程中将发生的指令记录到AOF缓冲区中，拷贝完成后将AOF缓冲区的数据以增量形式写入到AOF文件中替换旧的AOF文件</p>
<h2 id="RDB与AOF对比"><a href="#RDB与AOF对比" class="headerlink" title="RDB与AOF对比"></a>RDB与AOF对比</h2><p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221124211547737.png?raw=true" alt="image-20221124211547737"></p>
<h2 id="主从集群-一主多从，读写分离"><a href="#主从集群-一主多从，读写分离" class="headerlink" title="主从集群(一主多从，读写分离)"></a>主从集群(一主多从，读写分离)</h2><ul>
<li>建立连接阶段：主从节点间建立连接</li>
<li>数据同步阶段：执行数据的全量或增量复制</li>
<li>命令传播阶段：主节点将已执行的发给从节点，从节点接收命令并执行，实现主从数据的一致性</li>
</ul>
<p>​	缺点：主节点宕机后需要手动选择从节点，m  aster如果宕机不能进行写操作，不能实现高可用</p>
<p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221209151737449.png" alt="image-20221209151737449"></p>
<h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><p>​		slave结点加入到集群之后，发出数据同步请求</p>
<p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221125164247130.png?raw=true" alt="image-20221125164247130"></p>
<p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221125201625463.png?raw=true" alt="image-20221125201625463"></p>
<p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221125193052913.png?raw=true" alt="image-20221125193052913"></p>
<p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221125193243372.png?raw=true" alt="image-20221125193243372"></p>
<p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221125202133335.png?raw=true" alt="image-20221125202133335"></p>
<h2 id="哨兵集群-一个master，多个slave"><a href="#哨兵集群-一个master，多个slave" class="headerlink" title="哨兵集群(一个master，多个slave)"></a>哨兵集群(一个master，多个slave)</h2><p>​		哨兵模式是基于主从模式的，主要是为了解决主从模式下主节点发生故障导致无法提供写服务，无法将故障自动转移的问题，哨兵集群能实现对redis主从集群的监控、通知和自动故障转移  </p>
<p>​		哨兵节点之间互相被发现过程：哨兵节点只要跟主节点建立起了连接，就可以在主节点上发布自己的连接信息（ip和端口号）到 <code>sentinel:hello</code> 的频道，同时哨兵节点也可以从主节点上订阅信息，获取其它哨兵节点发布的连接信息。当多个哨兵节点在主节点上进行了发布和订阅后，他们就互相知道彼此的ip地址和端口号。</p>
<img src="C:\Users\19094\AppData\Roaming\Typora\typora-user-images\image-20240307204427362.png" alt="image-20240307204427362" style="zoom:50%;" />

<p>​		建立多个哨兵节点，每个哨兵节点会维护与其他节点的连接包括(master&#x2F;slave&#x2F;sentinel)，Sentinel周期性的给所有主从节点发送一次ping命令，如果从主节点没有在规定时间内响应哨兵的ping命令，哨兵就会把它标记为“主观下线”，同时通知其他哨兵节点判断主节点的连接情况，如果超过一半的哨兵节点认为主节点处于主观下线状态，则哨兵会认为该master节点已经处于客观下线状态，即master故障不可用，哨兵之间会选举哨兵leader，之后选举出的哨兵leader会在从节点中选出一个节点作为主节点进行故障转移。当master发生故障时，Sentinel会选择一个slave作为新的master执行slaveof no one，其余结点执行slaveof 新master，修改故障结点配置文件slaveof 新master，通知客户端主节点已更换</p>
<p>​		Sentinel选举新master的方式：首先过滤掉已经下线的节点，过滤掉响应慢的节点，判断slave节点的slave-priority值，值越小优先级越高；若slave-priority相同，则判断slave结点的offset大小，越大说明数据越全，优先级高；最后判断slave结点的id，越小优先级越高。</p>
<p>​		缺点：该模式只有一个master负责写操作，不能实现高并发的写操作。</p>
<p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221209151945054.png" alt="image-20221209151945054"></p>
<h2 id="分片集群-多个master，多个slave"><a href="#分片集群-多个master，多个slave" class="headerlink" title="分片集群(多个master，多个slave)"></a>分片集群(多个master，多个slave)</h2><p>​	分片集群支持高并发写操作，通过插槽slot存储数据，每个master包含一定数量的slot</p>
<img src="C:\Users\19094\AppData\Roaming\Typora\typora-user-images\image-20240307214256396.png" alt="image-20240307214256396" style="zoom:67%;" />

<h3 id="分片集群下如何查找key-Redis分片集群采用哈希槽而非一致性哈希"><a href="#分片集群下如何查找key-Redis分片集群采用哈希槽而非一致性哈希" class="headerlink" title="分片集群下如何查找key (Redis分片集群采用哈希槽而非一致性哈希)"></a>分片集群下如何查找key (Redis分片集群采用哈希槽而非一致性哈希)</h3><ol>
<li>客户端发送命令到 Redis 分片集群中的任意一个主节点，主节点根据命令涉及的key的哈希值 CRC16(key)%16384 计算出对应的槽号。     </li>
<li>主节点根据槽号确定该槽所在的主节点，并将命令路由到该主节点，由主节点处理命令并返回结果给客户端。</li>
</ol>
<h3 id="分片集群下节点增删"><a href="#分片集群下节点增删" class="headerlink" title="分片集群下节点增删"></a>分片集群下节点增删</h3><p>​	当节点加入或离开集群时，Redis 分片集群会自动进行数据的重新分片和迁移，以保持数据的均衡和高可用性。当一个新节点加入集群时，集群会将一部分槽从现有节点迁移到新节点上，以平衡数据负载。当一个节点离开集群时，集群会将该节点负责的槽迁移到其他可用节点上，以保证数据的可用性。     </p>
<p>​	故障转移：分为自动故障转移和手动故障转移( cluster failover命令将主-从替换为从-主 )</p>
<ul>
<li>手动故障转移：利用cluster failover命令可以手动让集群中的某个master宕机，切换到执行cluster failover命令的这个slave节点，实现无感知的数据迁移。</li>
</ul>
<p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221126140241320.png?raw=true" alt="image-20221126140241320"></p>
<ul>
<li>自动故障转移：类似哨兵集群中的故障转移，Redis集群的其他节点会周期性地向主节点发送心跳请求，一旦超过一定时间内无法收到心跳回复，就判定主节点为主观下线状态。当集群中超过一半的结点认为主节点为主观下线状态时，主节点进入客观下线状态并进行故障转移，Redis集群中的从节点会进行选举过程，选择一个从节点作为新的主节点。新的主节点将从之前的主节点同步数据，将自己的offset告诉其他从节点，当新的主节点同步完数据后，它会将自己变成主节点，并将相关信息广播给其他节点，更新集群配置。</li>
</ul>
<h1 id="Redis网络模型"><a href="#Redis网络模型" class="headerlink" title="Redis网络模型"></a>Redis网络模型</h1><h2 id="五种IO"><a href="#五种IO" class="headerlink" title="五种IO"></a>五种IO</h2><h3 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h3><p>​	阻塞IO在数据准备阶段和数据拷贝阶段都是阻塞的。应用进程调用recvfrom向内核请求数据，一直阻塞，等待内核数据准备好；内核数据准备好后将数据拷贝到用户空间，期间处于阻塞状态，直到拷贝完成返回成功指示</p>
<img src="C:\Users\19094\AppData\Roaming\Typora\typora-user-images\image-20240306224029479.png" alt="image-20240306224029479" style="zoom:67%;" />

<h3 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h3><p>​	非阻塞IO每个线程可以处理多个连接，但会进行频繁的系统调用，消耗资源。只能在数据准备阶段实现非阻塞，在数据拷贝阶段仍处于阻塞。应用进程反复调用recvfrom向内核请求数据 (每隔一段时间发出recvfrom请求)，如数据没有准备好则直接返回响应信息，去处理其他的事情，若数据准备好则将数据从内核空间拷贝到用户空间，期间处于阻塞，拷贝完成后返回成功指示</p>
<img src="C:\Users\19094\AppData\Roaming\Typora\typora-user-images\image-20240306224014494.png" alt="image-20240306224014494" style="zoom: 67%;" />

<h3 id="NIO为同步非阻塞IO"><a href="#NIO为同步非阻塞IO" class="headerlink" title="NIO为同步非阻塞IO"></a>NIO为同步非阻塞IO</h3><ul>
<li><p>同步和异步：同步和异步描述的是一种消息通知的机制，主动等待消息返回还是被动接受消息。同步io指的是调用方通过主动等待获取调用返回的结果来获取消息通知，而异步io指的是被调用方通过某种方式(如回调函数)来通知调用方获取消息。</p>
</li>
<li><p>阻塞非阻塞：阻塞和非阻塞描述的是调用方在获取消息过程中的状态，阻塞等待还是立刻返回。阻塞io指的是调用方在获取消息的过程中会挂起阻塞，直到获取到消息，而非阻塞io指的是调用方在获取io的过程中会立刻返回而不进行挂起。</p>
</li>
<li><p>因此，NIO是进程不断地向内核发出获取数据的请求而不是等待回调函数，这属于一个同步的过程。非阻塞体现在用户进程每次发出获取数据的请求时每次都会返回响应信息，不会一直阻塞等待数据准备好。</p>
</li>
</ul>
<h3 id="Java的NIO"><a href="#Java的NIO" class="headerlink" title="Java的NIO"></a>Java的NIO</h3><p>​	java的NIO主要通过selector，channel，buffer这三个部分来实现的，多个 Channel 以事件的形式注册到同一个 selector，即一个selector可以监听多个channel的连接请求或读写请求，通过轮询的机制轮询selector中多个channel的状态，通过单个线程就可以实现对多个通道的监听</p>
<h3 id="AIO为异步非阻塞IO"><a href="#AIO为异步非阻塞IO" class="headerlink" title="AIO为异步非阻塞IO"></a>AIO为异步非阻塞IO</h3><p>​	应用程序在发出系统调用时，会注册一个回调函数，当监听到内容从内核中取出并拷贝到用户空间时会通过调用回调函数进行读操作。在等待数据阶段和数据拷贝阶段都不会阻塞</p>
<h3 id="I-x2F-O多路复用：select，poll，epoll"><a href="#I-x2F-O多路复用：select，poll，epoll" class="headerlink" title="I&#x2F;O多路复用：select，poll，epoll"></a>I&#x2F;O多路复用：select，poll，epoll</h3><p>​	I&#x2F;O多路复：用单个进程&#x2F;线程就可以同时处理多个IO请求 (文件描述符)，即多个请求复用了一个进程&#x2F;线程</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>​		用户空间创建一个文件描述符集合fd_set (bitmap)，将要监听的文件描述符的位置置为1，然后将fd_set拷贝到内核空间，进程进入阻塞，并将每个fd放入等待队列中(可能多个进程读)，内核空间遍历所有的fd_set为1的fd判断是否有IO事件，如果有IO事件会把fd_set中有事件的位置置为1，没有事件的位置置为0，将fd_set从内核空间拷贝到用户空间，用户空间遍历fd_set中为1的位置，确认哪些fd就绪，然后开始处理</p>
<p>​		存在的问题：</p>
<ul>
<li>最大能监听的FD (通过FD可以找到对应的文件) 不超过1024</li>
<li>每次select都需要把所有要监听的FD(包括部分不需要监听的FD)拷贝到内核空间</li>
<li>内核将整个FD数组拷贝到用户空间</li>
<li>用户空间每次要遍历所有FD来判断就绪状态</li>
</ul>
<p>​		poll存在的问题：</p>
<ul>
<li>poll模式利用链表解决了select中监听FD数量受限的问题，但是由于要监听的FD较多，遍历时间复杂度为O(n)，性能很低</li>
</ul>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/513851017">epoll</a></h4><p>epoll的三个核心函数</p>
<ul>
<li><p>epoll_create：创建epoll实例，包括一棵红黑树管理添加的所有 socket 连接，一个双向链表接收所有就绪的文件描述符，一个进程等待队列（epoll_wait若就绪队列中无数据，会将当前进程加入到等待队列中）</p>
</li>
<li><p>epoll_ctl：注册一个socket即对应一个FD，创建一个红黑树节点存储FD并设置回调函数，将节点添加到红黑树中，红黑树中每个节点都关联一个socket连接,用于管理用户进程添加进来的所有socket连接 </p>
</li>
<li><p>epoll_wait：将epoll实例的rdlist链表中就绪的文件描述符通过该函数将数据发送到用户空间</p>
</li>
</ul>
<p>epoll的运行机制</p>
<ul>
<li>每个FD只需要执行一次epoll_ctl添加到红黑树，无需重复拷贝FD数据到内核空间，准备就绪的FD会添加到list就绪链表中，客户端发送请求给内核(如果链表为空，则等待FD就绪)</li>
<li>epoll中采用红黑树的结构保存要监听的FD，增删改查效率高 O(logn)，性能不会随着FD数量的增加而下降</li>
<li>当有文件描述符准备就绪时 (触发IO事件时)，会触发回调函数，将就绪的文件描述符放入就绪链表，等待epoll_wait的调用处理</li>
</ul>
<p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221126174401626.png?raw=true" alt="image-20221126174401626"></p>
<p>​		IO多路复用事件通知机制，当链表中有FD准备就绪时，调用epoll_wait方法可以得到通知，事件通知的模式有两种：</p>
<ul>
<li>LevelTriggered(水平触发)：LT，当被监听的文件描述符上有可读或可写事件发生时，每次 epoll_wait() 调用都会返回该文件描述符上的就绪事件。如果应用程序没有处理完该事件，下次 epoll_wait() 调用时仍会返回该事件。有数据可读读事件一直触发，以数据写入写事件一直触发，频繁触发效率低但是数据完整</li>
<li>EdgeTriggered(边缘触发)：ET，当被监听的文件描述符上有可读或可写事件发生时，只有在该文件描述符状态发生变化时，epoll_wait() 才会返回该事件。空的接收缓冲区刚接收到数据时触发读事件，满的缓冲区刚空出空间时触发读事件，触发次数少效率高但是不能保证数据的完整</li>
</ul>
<p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221126210244915.png?raw=true" alt="image-20221126210244915"> </p>
<p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221126214631747.png?raw=true" alt="image-20221126214631747"></p>
<p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20221126220035968.png?raw=true" alt="image-20221126220035968"></p>
<h2 id="Redis单线程"><a href="#Redis单线程" class="headerlink" title="Redis单线程"></a>Redis单线程</h2><p>​		redis单线程是指在redis中始终是由主线程来处理客户端请求的，因此redis的单线程就是意味着只有一个线程处理命令</p>
<p>​		redis多线程是指在redis4.0后除了主线程之外还引入了后台线程，后台线程主要负责异步释放redis内存，在redis6.0之后再网络模型中引入了多线程，提高对多核CPU的利用率。</p>
<h4 id="redis选择单线程处理命令原因："><a href="#redis选择单线程处理命令原因：" class="headerlink" title="redis选择单线程处理命令原因："></a>redis选择单线程处理命令原因：</h4><ul>
<li>redis是纯内存操作，执行速度非常快，CPU不是redis的瓶颈，多线程不会带来很大提升</li>
<li>多线程会导致上下文切换浪费CPU资源</li>
<li>多线程要面临线程安全问题，解决安全问题的实现复杂度高</li>
</ul>
<h4 id="redis为什么快"><a href="#redis为什么快" class="headerlink" title="redis为什么快"></a>redis为什么快</h4><ul>
<li>redis是基于内存的，读取数据很快</li>
<li>redis是单线程的，不需要频繁的进行线程上下文切换</li>
<li>redis线程模型中采用epoll多路复用技术，将各个操作转换为事件，io效率高</li>
</ul>
<h4 id="Redis单线程模型"><a href="#Redis单线程模型" class="headerlink" title="Redis单线程模型"></a>Redis单线程模型</h4><p>redis单线程模型中最为核心的就是事件处理器，包含多个socket，IO多路复用程序，socket队列，事件派发器，事件处理器。</p>
<p>工作原理：</p>
<ul>
<li>客户端与redis建立连接，通过socket方式与redis传输消息</li>
<li>IO多路复用程序把监听到的socket信息发送到socket队列中</li>
<li>事件派发器取出队列头部的socket，并派发给对应的事件处理器</li>
<li>只有当前事件处理完后派发器才能取后面的socket进行处理</li>
</ul>
<p><img src="https://img2020.cnblogs.com/blog/1140467/202007/1140467-20200701171414676-262569387.png" alt="img"></p>
<h1 id="Redis常见面试题"><a href="#Redis常见面试题" class="headerlink" title="Redis常见面试题"></a>Redis常见面试题</h1><h2 id="Redis作为缓存如何保证数据一致性"><a href="#Redis作为缓存如何保证数据一致性" class="headerlink" title="Redis作为缓存如何保证数据一致性"></a>Redis作为缓存如何保证数据一致性</h2><p>先删除缓存，后更新数据库 (更新数据库可能会加锁，时间可能比较长，导致缓存中的数据是不完整的，并发读写不一致，方法延迟双删)</p>
<p>先更新数据库，后删除缓存 (删除数据库数据成功后需要保证缓存删除成功，消息队列重试，基于binlog的消息队列)</p>
<ul>
<li>延迟双删 (解决并发读写不一致)<ul>
<li>线程1要想修改数据，先删除缓存，再更新数据库。</li>
<li>线程2来读缓存发现没有则从数据库中读取，由于线程1未完成数据库的更新，所以线程2读取到旧值并写入缓存</li>
<li>线程1根据估算sleep一段时间 (大于线程2读数据+写缓存的时间)，缓存被再次删除</li>
<li>如果有其他线程来读取缓存，会再次从数据库中读取新值</li>
</ul>
</li>
</ul>
<img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20230211210341364.png" alt="image-20230211210341364" style="zoom:67%;" />



<ul>
<li><p>消息队列重试 (缓存删除失败，该方式需要修改业务代码，不推荐)</p>
<ul>
<li>更新数据库</li>
<li>将需要删除的key发送给消息队列</li>
<li>利用消息队列的失败重试机制删除缓存</li>
</ul>
<img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20230211211841853.png" alt="image-20230211211841853" style="zoom: 67%;" />
</li>
<li><p>基于binlog (缓存删除失败，不会产生脏代码，不影响原来的业务代码)</p>
<ul>
<li>更新数据库数据，同时binlog日志发生变更</li>
<li>canal监听binlog日志将数据发送到消息队列</li>
<li>利用消息队列的失败重试机制删除缓存实现更新数据库和删除缓存同时成功和失败</li>
</ul>
</li>
</ul>
<img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20230211212024840.png" alt="image-20230211212024840" style="zoom:67%;" />



<h2 id="Redis热key问题"><a href="#Redis热key问题" class="headerlink" title="Redis热key问题"></a>Redis热key问题</h2><h3 id="什么是热key"><a href="#什么是热key" class="headerlink" title="什么是热key"></a>什么是热key</h3><p>某个瞬间有大量的请求去访问redis上某个固定的key，服务端在读取数据时，往往会对数据进行分片(存储在Redis的哈希槽中)，但由于hash算法原因，访问同样的key会一直命中同一台redis服务器上，因此热点问题就会产生。</p>
<h3 id="如何发现热key"><a href="#如何发现热key" class="headerlink" title="如何发现热key"></a>如何发现热key</h3><ul>
<li>预估热点key</li>
<li>使用redis自带命令 <strong>hotkeys</strong>，执行redis-cli时加上–hotkeys选项</li>
</ul>
<h3 id="如何解决热key"><a href="#如何解决热key" class="headerlink" title="如何解决热key"></a>如何解决热key</h3><ul>
<li>使用一级缓存<ul>
<li>使用本地缓存框架caffeine或者Guava，将key先缓存的本地而不直接请求redis，由于本地服务器采取多服务器负载均衡的原因，会对固定的key打散到不同的服务器上进行处理，当然该方法无法实现缓存的强一致性</li>
</ul>
</li>
<li>将热key分散到不同的服务器<ul>
<li>将该key在多个redis节点上都备份一份，因为redis是根据key分配哈希槽，因此在初始化时将key拼接上随机尾缀<code>(0~N)</code>，将多个备份的key散落在各个redis节点上，查询的时候也是拼接成多个备份key中的一个，从而达到热key分散的效果</li>
</ul>
</li>
</ul>
<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><h3 id="布隆过滤器简介"><a href="#布隆过滤器简介" class="headerlink" title="布隆过滤器简介"></a>布隆过滤器简介</h3><ul>
<li><p>布隆过滤器<code>(BloomFilter)</code>是一种非常节省空间的概率数据结构，本质上是一个二进制数组。</p>
</li>
<li><p>在查找某个元素时，布隆过滤器能够判断其<code>一定不在集合中</code>或者<code>可能在集合中</code>，因为存在hash冲突的原因(多个元素映射到同一个bit位上)，所以布隆过滤器不支持删除元素。</p>
</li>
<li><p>可以通过增大空间来降低错误率，错误率是由于hash碰撞产生的。如某个元素的所有hash函数值所对应的位置的值都为1，导致未添加过的元素产生误判，增大空间可以减少hash冲突，降低错率。</p>
</li>
</ul>
<p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20230314221548482.png" alt="image-20230314221548482"></p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>支持海量数据判断元素是否存在</li>
<li>采用bit位存储信息，节省空间</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>由于存在hash碰撞，导致未添加过的元素产生误判而认为在布隆过滤器中存在，实际不存在</li>
<li>要求错误率越低，所需要的存储空间和查询时间也越多</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>在谷歌Guava依赖中实现了该过滤器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数为数据类型，第二个数组长度，第三个误判率，BloomFilte抽象类</span></span><br><span class="line">BloomFilter&lt;Integer&gt; bloomFilter = BloomFilter.create(Funnels.integerFunnel(), <span class="number">1000000L</span>, <span class="number">0.01</span>);</span><br><span class="line">bloomFilter.put(i);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">mightContain</span> <span class="operator">=</span> bloomFilter.mightContain(i);</span><br></pre></td></tr></table></figure>

<h3 id="布隆过滤器与hashmap相比的好处"><a href="#布隆过滤器与hashmap相比的好处" class="headerlink" title="布隆过滤器与hashmap相比的好处"></a>布隆过滤器与hashmap相比的好处</h3><ul>
<li>布隆过滤器在判断一个元素不存在时，可以直接返回不存在，而 HashMap 需要进行键值对的比较，如果存在哈希碰撞的情况，可能需要比较多个键值对。</li>
<li>采用位存储的结构，占用存储空间小，hashmap占用空间大</li>
</ul>
<h2 id="一致性hash算法"><a href="#一致性hash算法" class="headerlink" title="一致性hash算法"></a>一致性hash算法</h2><p>​	一致性哈希（Consistent Hashing）是一种常用的分布式系统中的哈希算法，用于解决负载均衡和故障容错等问题。它基于哈希函数将数据分散到不同的服务器上，以实现负载均衡的目的。</p>
<h3 id="普通hash算法："><a href="#普通hash算法：" class="headerlink" title="普通hash算法："></a>普通hash算法：</h3><p>​	对服务器的数量取模，在固定数量集群中，如果增加服务器会导致hash结果不同，所有缓存失效</p>
<img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20230315194626824.png" alt="image-20230315194626824" style="zoom:50%;" />

<h3 id="一致性Hash算法"><a href="#一致性Hash算法" class="headerlink" title="一致性Hash算法"></a>一致性Hash算法</h3><ul>
<li><p>将整个哈希空间按照顺时针的方向组成一个虚拟的圆环，称为hash环，空间为 [0 - 2^32-1]</p>
</li>
<li><p>选择服务器的主机名或IP作为关键字进行Hash，确定每个服务器在哈希环上的位置</p>
</li>
<li><p>存储数据时，对数据的名称等通过Hash算法计算出Hash值，确定此数据在哈希环上的位置，顺时针寻找遇到的第一台服务器就是存储和获取该数据的服务器</p>
</li>
</ul>
<img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20230315194730628.png" alt="image-20230315194730628" style="zoom: 50%;" />

<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>​	使用普通Hash算法，当服务器数量发生变化时会产生缓存雪崩导致系统崩溃。使用一致性哈希算法，当服务器数量发生变化时，只有一部分缓存会失效，不会对服务器产生过大压力</p>
<h3 id="存在Hash环的倾斜问题"><a href="#存在Hash环的倾斜问题" class="headerlink" title="存在Hash环的倾斜问题"></a>存在Hash环的倾斜问题</h3><p>​	简单说一下就是被缓存的服务器集中于一块区域导致大部分缓存对象在某一台服务器上，导致某些服务器压力过大。采用虚拟节点机制，对每一个服务器节点计算多个Hash，每个计算结果位置存放一个该服务节点，称为虚拟节点。一个物理节点对应多个虚拟节点，虚拟节点到实际节点存在映射关系。</p>
<img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20230315194702924.png" alt="image-20230315194702924" style="zoom:33%;" />

<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>高性能</li>
<li>可重入，采用Hash结构</li>
<li>防死锁</li>
<li>互斥性</li>
</ul>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ul>
<li><p>set key value nx ex 10</p>
<ul>
<li>生效时间写死，不能自动续约</li>
<li>在不设置过期时间的情况下如果因系统原因导致无法执行释放锁的命令会造成死锁</li>
</ul>
</li>
<li><p>RedissonLock，采用看门狗机制解决了生效时间写死的问题，但是不能避免哨兵模式下master宕机后slave没有保存锁，导致两个客户端持有一把锁的情况</p>
<ul>
<li><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20230325161238218.png" alt="image-20230325161238218" style="zoom: 80%;" />
</li>
<li><p><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20230624171710716.png" alt="image-20230624171710716"></p>
</li>
<li><p>Rlock rlock &#x3D; redissonClient .getLock( keyName )	初始化执行器</p>
</li>
<li><p>rlock.lock()   获得锁，使用lua脚本判断</p>
<ul>
<li>如果当前key不存在表示锁未被占用，通过hset写入一个Hash类型的数据，key为锁名称keyName，field为线程id，value为重入次数，并设置该key的生效时间。  hset store:1 threadId 1</li>
</ul>
</li>
<li><p>rlock.unlock()   释放锁，使用lua脚本判断</p>
<ul>
<li>判断当前线程对应的key是否存在，如果不存在就会返回nil; 否则，值自增-1，然后判断key的值是否大于零，如果大于零，刷新过期时间，返回0；否则删除当前锁del key，调用发布命令，并返回1</li>
</ul>
</li>
<li><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20230319191308539.png" alt="image-20230319191308539" style="zoom: 67%;" />
</li>
<li><img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20230325163532764.png" alt="image-20230325163532764" style="zoom: 53%;" />
</li>
<li><p>看门狗机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">rlock.lock(<span class="number">3</span>,TimeUnit.SECONDS);		<span class="comment">//自定义锁超时时间，不会开启看门狗</span></span><br><span class="line">rlock.lock(-<span class="number">1</span>,<span class="literal">null</span>);	<span class="comment">//将锁超时时间设置为-1，开启看门狗机制，默认30秒内锁过期，为了在锁过期前执行完业务，若时间超过 10即(1/3) 秒业务没有执行完，则调用renewExpiration()方法自动续期，重新设置过期时间30秒 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">boolean</span> interruptibly)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">	<span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> tryAcquire(leaseTime, unit, threadId);   <span class="comment">//如果redis已经获得锁返回ttl具体的值，如果没有锁返回nil</span></span><br><span class="line">    <span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123; 	<span class="keyword">return</span>;  &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;		<span class="comment">//由于ttl不为null，循环判断锁剩余时间</span></span><br><span class="line">        ttl = tryAcquire(leaseTime, unit, threadId);</span><br><span class="line">        <span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;  <span class="keyword">break</span>;  &#125; </span><br><span class="line">    	<span class="comment">//执行xxx</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; RFuture&lt;Long&gt; <span class="title function_">tryAcquireAsync</span><span class="params">(<span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> tryLockInnerAsync(leaseTime, unit, threadId, RedisCommands.EVAL_LONG);	<span class="comment">//自定义过期时间</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        scheduleExpirationRenewal(threadId);	<span class="comment">//开启看门狗机制，这是一个定时任务，每隔10s执行一次renewExpiration()方法自动续期</span></span><br><span class="line">    <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//编写redisson的配置文件</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer()	<span class="comment">//使用单节点redis</span></span><br><span class="line">                .setAddress(<span class="string">&quot;redis://8.130.75.142:6379&quot;</span>)</span><br><span class="line">                .setPingConnectionInterval(<span class="number">1000</span>)		<span class="comment">//防止一段时间过后与redis的连接断开</span></span><br><span class="line">                .setDatabase(<span class="number">0</span>);</span><br><span class="line">        config.setLockWatchdogTimeout(<span class="number">30</span> * <span class="number">1000</span>);		<span class="comment">//设置看门狗的过期时间</span></span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redissonClient</span> <span class="operator">=</span> Redisson.create(config);	</span><br><span class="line">        <span class="keyword">return</span> redissonClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="type">RLock</span> <span class="variable">rlock</span> <span class="operator">=</span> redissonClient.getLock(RedisUtil.getSuoStoreKey() + storeId);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    rlock.lock(<span class="number">3</span>,TimeUnit.SECONDS);</span><br><span class="line">      <span class="comment">//rlock.lock(-1,null);</span></span><br><span class="line">      <span class="comment">//rlock.tryLock(3,10,TimeUnit.SECONDS);	//设置锁等待时间，设置锁超时时间</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> redisTemplate.opsForValue().get(RedisUtil.getStoreKey() + storeId);</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>)  	<span class="comment">//&quot;商品不存在&quot;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((Integer)obj &lt;= <span class="number">0</span>)		<span class="comment">//&quot;商品已售完&quot;</span></span><br><span class="line">    <span class="keyword">else</span> redisTemplate.opsForValue().decrement(RedisUtil.getStoreKey() + storeId);	<span class="comment">//扣库存</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (rlock.isHeldByCurrentThread())	<span class="comment">//只有当前线程持有才能释放锁，避免超时之后释放其他线程加的锁</span></span><br><span class="line">        rlock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>RedLock，在哨兵模式下，如果master宕机发生主从切换，能够实现只有一个客户端可以持有锁，但是对性能影响较大</p>
<ul>
<li>该方法认为在设置锁时从节点会同步主节点的key，在获取锁时依次向每个Redis节点发出请求，询问是否可以获得该锁，如果超过半数节点能够获取到锁，则获取成功。如果锁获取成功，那么锁释放时间就是最初的锁释放时间减去在集群中获取锁所消耗的时间。如果锁获取失败，客户端会到每个master节点上释放锁。</li>
</ul>
</li>
</ul>
<h3 id="面对高并发场景时分布式锁的优化"><a href="#面对高并发场景时分布式锁的优化" class="headerlink" title="面对高并发场景时分布式锁的优化"></a>面对高并发场景时分布式锁的优化</h3><p>沿用ConcurrentHashmap的思想，我们将单锁转换为分段锁的形式，使得多个线程可以并发访问分布式锁，大幅度提升并发效率。】</p>
<p>以库存为例：</p>
<ul>
<li>首先我们将库存分为若干个hash存储，stock_1,stock_2,stock_3,….</li>
<li>然后并发访问时，选择一个随机值，从若干的stock中去取库存</li>
<li>如果遇到库存为空的情况时，自动释放锁，切换到下一个库去取</li>
<li>该方式虽能有效提高分布式锁的并发效率，但会增加代码的难度，实现起来较为复杂</li>
</ul>
<h3 id="集群模式下mget使用"><a href="#集群模式下mget使用" class="headerlink" title="集群模式下mget使用"></a>集群模式下mget使用</h3><p>​	如果在集群模式下，在使用mget时，如果发生不同key在多个节点上，则需要向多个节点发送请求，这会增加网络开销和延迟。因此为确保mget执行效率高，我们会将业务相同的key存入同一个节点中。在集群模式下通过取key得hash值映射到对应结点的槽上，业务相同则可以指定redis的key命名为<code>&#123;yewu&#125;_abc</code>，这时redis在对key计算hash值时只会取{}中的值</p>
<h3 id="Redis大Key"><a href="#Redis大Key" class="headerlink" title="Redis大Key"></a>Redis大Key</h3><h4 id="大key规定"><a href="#大key规定" class="headerlink" title="大key规定"></a>大key规定</h4><ul>
<li>公司内部标准：<img src="https://gitlab.com/littlebean1/photoproject/-/raw/main/image-20230918173952155.png" alt="image-20230918173952155"></li>
</ul>
<h4 id="引发的问题"><a href="#引发的问题" class="headerlink" title="引发的问题"></a>引发的问题</h4><p>​		网络阻塞，程序在读取大key的时候由于key过大，导致网络需要传输的数据过多引发网络阻塞</p>
<p>​		清除大key时阻塞redis主线程</p>
<p>​		如果是在集群环境下出现大key的问题，会导致某个redis服务器内存占用过大负载过高，无法实现内存均衡，造成集群分片不均匀。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>​		采用hash打散的方式存储，将1000000条数据打散为1000000&#x2F;1000&#x3D;1000个hash表中，实现打散拆解大Key。在删除redis中的大key时，不使用del命令去处理而是使用unlink key等命令，因为del命令会导致主线程卡顿阻塞。对于string类型采取合适的算法压缩value</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%9B%BE%E8%A7%A3redis/" rel="tag"># 图解redis</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/10/16/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" rel="prev" title="消息队列">
                  <i class="fa fa-chevron-left"></i> 消息队列
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/10/27/%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8%E5%88%A4%E7%8E%AF/" rel="next" title="算法-链表判环">
                  算法-链表判环 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bean</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
